name: Fetch and Process Remote SmartDNS Rules Separately

on:
  schedule:
    # 每天凌晨3点执行 (UTC时间，根据需要调整)
    - cron: '0 3 * * *'
  workflow_dispatch: # 允许手动触发

permissions: # <--- ADD THIS BLOCK
  contents: write # Allows the GITHUB_TOKEN to write to the repository contents (push commits)

jobs:
  fetch_and_process:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # 检出你自己的仓库，以便提交结果
        # No need to explicitly pass token here if permissions are set globally/job-level

      - name: Fetch and process rules
        id: process_rules # 给这个步骤一个id，方便后续步骤引用其输出（如果需要）
        run: |
          # 定义输入URL和它们对应的输出文件名
          # 使用Bash关联数组 (declare -A)
          declare -A RULE_SOURCES
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/proxy-list.txt"]="smartdns_proxy_rules.txt"
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/direct-list.txt"]="smartdns_direct_rules.txt"
          # 如果有更多源，可以继续添加:
          # RULE_SOURCES["ANOTHER_URL"]="another_output.txt"

          # 存储实际被处理并可能发生更改的文件名
          PROCESSED_OUTPUT_FILES=()

          for url in "${!RULE_SOURCES[@]}"; do
            output_filename="${RULE_SOURCES[$url]}"
            tmp_processed_file="tmp_${output_filename}" # 临时文件用于处理

            echo "Processing: ${url}  -> ${output_filename}"

            # 下载文件内容，去除 "full:"
            # 使用 curl -fsSL:
            # -f: fail silently on server errors (important for the 'if !' check)
            # -s: silent mode
            # -S: show error on stderr if -s is also used
            # -L: follow redirects
            if ! curl -fsSL "${url}" | sed 's/^full://' > "${tmp_processed_file}"; then
              echo "Warning: Failed to download or initially process ${url}. Skipping this source."
              rm -f "${tmp_processed_file}" # 清理不完整的临时文件
              continue # 继续处理下一个URL
            fi

            # 如果下载和初步处理成功，且临时文件非空，则进行排序去重
            if [ -s "${tmp_processed_file}" ]; then
              sort -u "${tmp_processed_file}" > "${output_filename}"
              echo "Processed rules saved to ${output_filename}"
              echo "Total lines in ${output_filename}: $(wc -l < ${output_filename})"
              PROCESSED_OUTPUT_FILES+=("${output_filename}")
            else
              echo "Warning: Content for ${url} resulted in an empty file after processing. ${output_filename} will not be created or updated from this source."
              # 如果你希望即使源为空也创建一个空的输出文件，取消下面这行的注释
              # > "${output_filename}"
              # PROCESSED_OUTPUT_FILES+=("${output_filename}") # 如果创建空文件也算作“已处理”
            fi

            # 清理临时文件
            rm -f "${tmp_processed_file}"
          done

          # 将成功处理并生成（或更新）的文件名列表传递给 GITHUB_ENV
          # 这样下一步就可以知道哪些文件需要被添加到git
          if [ ${#PROCESSED_OUTPUT_FILES[@]} -gt 0 ]; then
            echo "Successfully processed files: ${PROCESSED_OUTPUT_FILES[*]}"
            # 将数组转换为一个空格分隔的字符串
            echo "FILES_TO_COMMIT_LIST=${PROCESSED_OUTPUT_FILES[*]}" >> $GITHUB_ENV
          else
            echo "No files were successfully processed or updated."
            echo "FILES_TO_COMMIT_LIST=" >> $GITHUB_ENV
          fi

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # 从 GITHUB_ENV 获取上一步生成的文件列表
          # FILES_TO_COMMIT_LIST 变量现在包含了所有实际被处理过的文件名
          
          if [ -z "$FILES_TO_COMMIT_LIST" ]; then
            echo "No files were processed in the previous step. Nothing to commit."
            exit 0
          fi

          # 将字符串转换回 Bash 数组
          IFS=' ' read -r -a files_to_stage <<< "$FILES_TO_COMMIT_LIST"

          echo "Files to check for staging: ${files_to_stage[*]}"
          
          added_any_file=false
          for file in "${files_to_stage[@]}"; do
            if [ -f "$file" ]; then # 确保文件存在
              git add "$file"
              echo "Added $file to staging area."
              added_any_file=true
            else
              echo "Warning: Expected file $file not found. Skipping add."
            fi
          done

          if ! $added_any_file; then
            echo "No files were actually added to staging (e.g., all sources failed or resulted in no change to existing empty files)."
            exit 0
          fi
          
          # 检查是否有暂存的更改
          if git diff --staged --quiet; then
            echo "No actual changes to commit in the staged files."
          else
            changed_files_names=$(git diff --staged --name-only | tr '\n' ' ' | sed 's/ $//')
            echo "Changes detected in: $changed_files_names. Committing..."
            git commit -m "Update SmartDNS rules (Automated): $changed_files_names"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This is good practice but often redundant if permissions are set correctly
          # FILES_TO_COMMIT_LIST 将由上一步通过 GITHUB_ENV 注入
