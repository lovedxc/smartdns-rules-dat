name: Fetch and Process Remote SmartDNS Rules Separately

on:
  schedule:
    # 每天凌晨3点执行 (UTC时间，根据需要调整)
    - cron: '0 3 * * *'
  workflow_dispatch: # 允许手动触发

permissions:
  contents: write # 允许 GITHUB_TOKEN 写入仓库内容 (推送提交)

jobs:
  fetch_and_process:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # 检出你自己的仓库，以便提交结果

      - name: Fetch and process rules
        id: process_rules
        run: |
          # 定义输入URL和它们对应的输出文件名
          declare -A RULE_SOURCES
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/proxy-list.txt"]="smartdns_proxy_rules.txt"
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/direct-list.txt"]="smartdns_direct_rules.txt"

          PROCESSED_OUTPUT_FILES=()
          DOMAIN_TO_FORCE_DIRECT="services.googleapis.cn"

          for url in "${!RULE_SOURCES[@]}"; do
            output_filename="${RULE_SOURCES[$url]}"
            tmp_processed_file="tmp_${output_filename}"

            echo "Processing: ${url}  -> ${output_filename}"

            # 1. Download, convert line endings, remove 'full:', remove 'regexp:' lines
            if ! curl -fsSL "${url}" | \
                # Convert CRLF to LF
                sed 's/\r$//' | \
                sed 's/^full://' | \
                grep -v '^regexp:' > "${tmp_processed_file}"; then
              echo "警告: 下载或初步处理 ${url} 失败。跳过此源。"
              rm -f "${tmp_processed_file}"
              continue
            fi

            # 2. Trim leading/trailing whitespace from all lines and remove any resulting empty lines
            if [ -s "${tmp_processed_file}" ]; then # Only process if file has content
              echo "DEBUG: Trimming whitespace and removing empty lines from '${tmp_processed_file}'."
              mv "${tmp_processed_file}" "${tmp_processed_file}.untrimmed"
              # Trim leading/trailing whitespace, then remove any lines that became empty
              sed 's/^[[:space:]]*//; s/[[:space:]]*$//' "${tmp_processed_file}.untrimmed" | grep -v '^$' > "${tmp_processed_file}"
              # If the result is an empty file, but original was not, it means all lines were whitespace or became empty
              if [ ! -s "${tmp_processed_file}" ] && [ -s "${tmp_processed_file}.untrimmed" ]; then
                  echo "DEBUG: After trimming, '${tmp_processed_file}' became empty. Original content was likely all whitespace or lines that became empty."
              fi
              rm -f "${tmp_processed_file}.untrimmed"
            else
              echo "DEBUG: '${tmp_processed_file}' was empty or did not exist before whitespace trimming step. Skipping trimming."
            fi

            # 3. DEBUG: Check for the specific domain after initial processing AND TRIMMING
            echo "DEBUG: Checking for '${DOMAIN_TO_FORCE_DIRECT}' in TRIMMED '${tmp_processed_file}' before custom logic:"
            if grep -qF "^${DOMAIN_TO_FORCE_DIRECT}$" "${tmp_processed_file}"; then
              echo "DEBUG: '${DOMAIN_TO_FORCE_DIRECT}' IS FOUND in TRIMMED '${tmp_processed_file}' before custom logic."
            else
              echo "DEBUG: '${DOMAIN_TO_FORCE_DIRECT}' IS NOT FOUND (exact match ^...$) in TRIMMED '${tmp_processed_file}' before custom logic."
              echo "DEBUG: Searching for '${DOMAIN_TO_FORCE_DIRECT}' as a substring in TRIMMED '${tmp_processed_file}' (showing special chars for up to 5 matches):"
              grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${tmp_processed_file}" | cat -vet | head -n 5 || echo "DEBUG: Substring '${DOMAIN_TO_FORCE_DIRECT}' also not found."
            fi

            # 4. --- 开始自定义规则调整 ---
            if [ "${output_filename}" == "smartdns_proxy_rules.txt" ]; then
              echo "Attempting to remove '${DOMAIN_TO_FORCE_DIRECT}' from '${tmp_processed_file}' (for proxy list)..."
              
              echo "DEBUG: Content of '${tmp_processed_file}' that *should* contain '${DOMAIN_TO_FORCE_DIRECT}' for removal (showing special chars):"
              grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${tmp_processed_file}" | cat -vet | head -n 5 || echo "DEBUG: For proxy list, '${DOMAIN_TO_FORCE_DIRECT}' not found by grep -F for cat -vet prior to removal attempt."

              lines_before_removal=$(wc -l < "${tmp_processed_file}")
              
              tmp_mod_file_for_removal="${tmp_processed_file}.removing"
              grep -vF "^${DOMAIN_TO_FORCE_DIRECT}$" "${tmp_processed_file}" > "${tmp_mod_file_for_removal}"
              
              lines_in_mod_file=$(wc -l < "${tmp_mod_file_for_removal}")

              if [ "$lines_in_mod_file" -lt "$lines_before_removal" ]; then
                echo "DEBUG: grep -vF removed lines. Mod file: $lines_in_mod_file lines, Original temp: $lines_before_removal lines."
              else
                echo "DEBUG: grep -vF did NOT remove lines. Mod file: $lines_in_mod_file lines, Original temp: $lines_before_removal lines. Domain might not have matched '^...$' or was not present as expected."
              fi
              mv "${tmp_mod_file_for_removal}" "${tmp_processed_file}"
                            
              lines_after_removal=$(wc -l < "${tmp_processed_file}")
              echo "DEBUG: Lines in '${tmp_processed_file}' for proxy. Before removal logic: ${lines_before_removal}. After removal attempt: ${lines_after_removal}."

              if grep -qF "^${DOMAIN_TO_FORCE_DIRECT}$" "${tmp_processed_file}"; then
                echo "ERROR: '${DOMAIN_TO_FORCE_DIRECT}' IS STILL FOUND (exact match ^...$) in '${tmp_processed_file}' after removal attempt for proxy list!"
                echo "DEBUG: First 5 lines of '${tmp_processed_file}' containing the domain (showing special chars):"
                grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${tmp_processed_file}" | cat -vet | head -n 5
              else
                echo "DEBUG: '${DOMAIN_TO_FORCE_DIRECT}' successfully removed or was not present (exact match ^...$) after removal attempt in '${tmp_processed_file}' for proxy list."
              fi
            fi

            if [ "${output_filename}" == "smartdns_direct_rules.txt" ]; then
              echo "Ensuring '${DOMAIN_TO_FORCE_DIRECT}' is in '${tmp_processed_file}' (for direct list)..."
              # Add if not present (exact match). sort -u will handle duplicates if already present.
              if ! grep -qF "^${DOMAIN_TO_FORCE_DIRECT}$" "${tmp_processed_file}"; then
                echo "${DOMAIN_TO_FORCE_DIRECT}" >> "${tmp_processed_file}"
                echo "DEBUG: Added '${DOMAIN_TO_FORCE_DIRECT}' to '${tmp_processed_file}' for direct list."
              else
                echo "DEBUG: '${DOMAIN_TO_FORCE_DIRECT}' (exact match ^...$) was already present in '${tmp_processed_file}' for direct list."
              fi
            fi
            # --- 结束自定义规则调整 ---

            # 5. Sort and finalize
            if [ -s "${tmp_processed_file}" ]; then
              sort -u "${tmp_processed_file}" > "${output_filename}"
              echo "处理后的规则已保存到 ${output_filename}"
              echo "${output_filename} 中的总行数: $(wc -l < ${output_filename})"
              PROCESSED_OUTPUT_FILES+=("${output_filename}")
            else
              echo "警告: '${tmp_processed_file}' (for ${output_filename}) is empty before final sort. ${output_filename} will be empty or not updated."
              # If you want to ensure an empty file is created even if the source was empty or processing made it empty:
              # > "${output_filename}"
              # PROCESSED_OUTPUT_FILES+=("${output_filename}")
            fi

            rm -f "${tmp_processed_file}"
          done

          if [ ${#PROCESSED_OUTPUT_FILES[@]} -gt 0 ]; then
            echo "成功处理的文件: ${PROCESSED_OUTPUT_FILES[*]}"
            echo "FILES_TO_COMMIT_LIST=${PROCESSED_OUTPUT_FILES[*]}" >> $GITHUB_ENV
          else
            echo "没有文件被成功处理或更新。"
            echo "FILES_TO_COMMIT_LIsT=" >> $GITHUB_ENV
          fi

      - name: Commit and push changes
        # ... (this part remains the same)
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [ -z "$FILES_TO_COMMIT_LIST" ]; then
            echo "上一步没有处理任何文件。无需提交。"
            exit 0
          fi

          IFS=' ' read -r -a files_to_stage <<< "$FILES_TO_COMMIT_LIST"
          echo "待检查暂存的文件: ${files_to_stage[*]}"
          
          added_any_file=false
          for file in "${files_to_stage[@]}"; do
            if [ -f "$file" ]; then
              git add "$file"
              echo "已将 $file 添加到暂存区。"
              added_any_file=true
            else
              echo "警告: 预期的文件 $file 未找到。跳过添加。"
            fi
          done

          if ! $added_any_file; then
            echo "没有文件实际被添加到暂存区。"
            exit 0
          fi
          
          if git diff --staged --quiet; then
            echo "暂存的文件中没有实际更改需要提交。"
          else
            changed_files_names=$(git diff --staged --name-only | tr '\n' ' ' | sed 's/ $//')
            echo "在以下文件中检测到更改: $changed_files_names. 正在提交..."
            git commit -m "Update SmartDNS rules (Automated): $changed_files_names"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
