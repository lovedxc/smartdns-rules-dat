name: Fetch and Process Remote SmartDNS Rules Separately

on:
  schedule:
    # 每天凌晨3点执行 (UTC时间，根据需要调整)
    - cron: '0 3 * * *'
  workflow_dispatch: # 允许手动触发

permissions:
  contents: write # 允许 GITHUB_TOKEN 写入仓库内容 (推送提交)

jobs:
  fetch_and_process:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fetch and process rules
        id: process_rules
        run: |
          declare -A RULE_SOURCES
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/proxy-list.txt"]="smartdns_proxy_rules.txt"
          RULE_SOURCES["https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/release/direct-list.txt"]="smartdns_direct_rules.txt"

          PROCESSED_OUTPUT_FILES=()
          DOMAIN_TO_FORCE_DIRECT="services.googleapis.cn"

          echo "DEBUG: The domain we are trying to manage is: '${DOMAIN_TO_FORCE_DIRECT}'"
          echo "DEBUG: The domain variable with cat -vet: "
          echo "${DOMAIN_TO_FORCE_DIRECT}" | cat -vet

          for url in "${!RULE_SOURCES[@]}"; do
            output_filename="${RULE_SOURCES[$url]}"
            tmp_processed_file="tmp_final_${output_filename}" # Final temp file before sort
            intermediate_debug_file="tmp_intermediate_debug_${output_filename}" # For proxy list debugging

            echo "Processing: ${url}  -> ${output_filename}"

            # 初始的通用处理阶段: 下载 -> CRLF转LF -> 修剪行首尾空格 -> 去full: -> 去regexp:
            # 这个结果将用于进一步操作或直接成为 tmp_processed_file 的基础
            
            # 创建一个临时的管道输出文件，用于所有初始处理步骤
            initial_stream_output_tmp="tmp_initial_stream_${output_filename}"

            if ! curl -fsSL "${url}" | \
                sed 's/\r$//' | \
                sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | \
                sed 's/^full://' | \
                grep -v '^regexp:' > "${initial_stream_output_tmp}"; then
              echo "警告: 下载或通用处理 ${url} 失败。跳过此源。"
              rm -f "${initial_stream_output_tmp}"
              continue
            fi

            # 根据文件名进行特定处理
            if [ "${output_filename}" == "smartdns_proxy_rules.txt" ]; then
              echo "DEBUG PROXY: Starting specific processing for ${output_filename}"
              
              # 复制 initial_stream_output_tmp 到 intermediate_debug_file 以便检查
              cp "${initial_stream_output_tmp}" "${intermediate_debug_file}"

              echo "DEBUG PROXY: Content of '${intermediate_debug_file}' (lines with '${DOMAIN_TO_FORCE_DIRECT}') BEFORE targeted removal (top 10 matches, cat -vet):"
              if grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${intermediate_debug_file}"; then
                grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${intermediate_debug_file}" | cat -vet | head -n 10
              else
                echo "DEBUG PROXY: '${DOMAIN_TO_FORCE_DIRECT}' not found as substring in '${intermediate_debug_file}'."
              fi
              
              echo "DEBUG PROXY: Attempting: grep -vF \"^${DOMAIN_TO_FORCE_DIRECT}$\" \"${intermediate_debug_file}\" > \"${tmp_processed_file}\""
              grep -vF "^${DOMAIN_TO_FORCE_DIRECT}$" "${intermediate_debug_file}" > "${tmp_processed_file}"
              # 检查 grep 的退出状态 (0=匹配并操作, 1=未找到匹配行所以未操作, >1=错误)
              grep_exit_status=$?
              echo "DEBUG PROXY: Exit status of grep -vF command: ${grep_exit_status}"


              echo "DEBUG PROXY: Content of '${tmp_processed_file}' (lines with '${DOMAIN_TO_FORCE_DIRECT}') AFTER targeted removal (top 10 matches, cat -vet):"
              if grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${tmp_processed_file}"; then
                echo "ERROR PROXY: '${DOMAIN_TO_FORCE_DIRECT}' IS STILL FOUND in '${tmp_processed_file}'."
                grep -F "${DOMAIN_TO_FORCE_DIRECT}" "${tmp_processed_file}" | cat -vet | head -n 10
              else
                echo "DEBUG PROXY: '${DOMAIN_TO_FORCE_DIRECT}' NOT found as substring in '${tmp_processed_file}'. Removal likely successful or it was not there after initial processing."
              fi
              rm -f "${intermediate_debug_file}"

            elif [ "${output_filename}" == "smartdns_direct_rules.txt" ]; then
              echo "DEBUG DIRECT: Starting specific processing for ${output_filename}"
              # 对于直连列表，直接使用初始处理的结果，然后追加域名
              cp "${initial_stream_output_tmp}" "${tmp_processed_file}" # 使用初始处理的结果
              
              echo "DEBUG DIRECT: Appending '${DOMAIN_TO_FORCE_DIRECT}' to '${tmp_processed_file}'."
              echo "${DOMAIN_TO_FORCE_DIRECT}" >> "${tmp_processed_file}"
            else
              # 对于其他任何文件，直接使用初始处理的结果
              cp "${initial_stream_output_tmp}" "${tmp_processed_file}"
            fi
            
            rm -f "${initial_stream_output_tmp}" # 清理初始管道输出文件

            # 统一处理：排序去重并保存 (只对存在且非空的 tmp_processed_file 操作)
            if [ -f "${tmp_processed_file}" ] && [ -s "${tmp_processed_file}" ]; then
              sort -u "${tmp_processed_file}" > "${output_filename}"
              echo "处理后的规则已保存到 ${output_filename}"
              echo "${output_filename} 中的总行数: $(wc -l < ${output_filename})"
              PROCESSED_OUTPUT_FILES+=("${output_filename}")
            elif [ -f "${tmp_processed_file}" ]; then # 文件存在但是是空的
              echo "警告: ${tmp_processed_file} 在排序前为空。 ${output_filename} 将为空。"
              # 创建一个空的输出文件
              > "${output_filename}"
              PROCESSED_OUTPUT_FILES+=("${output_filename}")
            else # tmp_processed_file 根本没创建（例如，初始下载失败后跳过了）
              echo "警告: ${tmp_processed_file} 未创建。 ${output_filename} 不会更新。"
            fi

            rm -f "${tmp_processed_file}" # 清理最终的临时文件
          done

          if [ ${#PROCESSED_OUTPUT_FILES[@]} -gt 0 ]; then
            echo "成功处理的文件: ${PROCESSED_OUTPUT_FILES[*]}"
            echo "FILES_TO_COMMIT_LIST=${PROCESSED_OUTPUT_FILES[*]}" >> $GITHUB_ENV
          else
            echo "没有文件被成功处理或更新。"
            echo "FILES_TO_COMMIT_LIST=" >> $GITHUB_ENV
          fi

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [ -z "$FILES_TO_COMMIT_LIST" ]; then
            echo "上一步没有处理任何文件。无需提交。"
            exit 0
          fi

          IFS=' ' read -r -a files_to_stage <<< "$FILES_TO_COMMIT_LIST"
          echo "待检查暂存的文件: ${files_to_stage[*]}"
          
          added_any_file=false
          for file in "${files_to_stage[@]}"; do
            if [ -f "$file" ]; then
              git add "$file"
              echo "已将 $file 添加到暂存区。"
              added_any_file=true
            else
              echo "警告: 预期的文件 $file 未找到。跳过添加。"
            fi
          done

          if ! $added_any_file; then
            echo "没有文件实际被添加到暂存区。"
            exit 0
          fi
          
          if git diff --staged --quiet; then
            echo "暂存的文件中没有实际更改需要提交。"
          else
            changed_files_names=$(git diff --staged --name-only | tr '\n' ' ' | sed 's/ $//')
            echo "在以下文件中检测到更改: $changed_files_names. 正在提交..."
            git commit -m "Update SmartDNS rules (Automated): $changed_files_names"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
